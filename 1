task.wait(0.7)
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local Player = Players.LocalPlayer
local place = game.PlaceId

-- Lost Connection ë°©ì§€ (wait ì œê±°)
local function PreventLostConnection()
    TeleportService.TeleportInitFailed:Connect(function(player, teleportResult, errorMessage)
        warn("í…”ë ˆí¬íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨:", teleportResult, errorMessage)
    end)
    game:GetService("GuiService").ErrorMessageChanged:Connect(function() end)
    game:GetService("NetworkClient").ChildRemoved:Connect(function()
        warn("ë„¤íŠ¸ì›Œí¬ ì—°ê²° ëŠì–´ì§ ê°ì§€")
    end)
end
PreventLostConnection()

-- ìºë¦­í„° ì¤€ë¹„ ëŒ€ê¸°
local function WaitForCharacter()
    if not Player.Character or not Player.Character:FindFirstChild("HumanoidRootPart") then
        Player.CharacterAdded:Wait()
        repeat task.wait(0.17) until Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
    end
end

-- ì•ˆì „í•œ ì„œë²„ í˜¸ì¶œ
local function SafeInvoke(funcName, args)
    if type(args) ~= "table" then args = {args} end
    local success, result = pcall(function()
        WaitForCharacter()
        return ReplicatedStorage:WaitForChild("Chest"):WaitForChild("Remotes")
            :WaitForChild("Functions"):WaitForChild(funcName)
            :InvokeServer(unpack(args))
    end)
    if not success then warn("InvokeServer ì˜¤ë¥˜:", funcName, result) end
    return success
end

-- Tashi Blade ì¥ì°©
local function EnsureTashiBlade()
    WaitForCharacter()
    if not Player.Backpack:FindFirstChild("Tashi Blade") and not Player.Character:FindFirstChild("Tashi Blade") then
        local args = {"Tashi Blade"}
        SafeInvoke("InventoryEq", args)
    end
end

-- SeaMonsterSpawnText ì‹œê°„ íŒŒì‹± í•¨ìˆ˜
local function ParseSeaMonsterTime()
    local success, seaMonsterText = pcall(function()
        return ReplicatedStorage:GetAttribute("SeaMonsterSpawnText") or "00:00:00"
    end)
    
    if not success then return 0 end
    
    local hours, minutes, seconds = string.match(seaMonsterText, "(%d+):(%d+):(%d+)")
    if hours and minutes and seconds then
        return tonumber(hours) * 3600 + tonumber(minutes) * 60 + tonumber(seconds)
    end
    return 0
end

-- ì´ë™ í•¨ìˆ˜
local function TeleportToChest()
    WaitForCharacter()
    local island = Workspace:FindFirstChild("Island")
    if island then
        local chestSpawner = island:FindFirstChild("ChestSpawner", true)
        if chestSpawner then
            Player.Character.HumanoidRootPart.CFrame = chestSpawner.CFrame
            return true
        end
    end
    return false
end

local function TeleportToSeaKingBody()
    WaitForCharacter()
    local body = Workspace:FindFirstChild("SeaMonster")
        and Workspace.SeaMonster:FindFirstChild("SeaKing")
        and Workspace.SeaMonster.SeaKing:FindFirstChild("SeaKing")
        and Workspace.SeaMonster.SeaKing.SeaKing:FindFirstChild("Body")
    if body then
        -- Bodyì˜ ì•„ë˜ìª½ê³¼ ë” ì•ìª½ìœ¼ë¡œ í…”ë ˆí¬íŠ¸ (Xì¶• +30, Yì¶• -10 ì˜¤í”„ì…‹)
        local targetCFrame = body.CFrame * CFrame.new(30, -10, 0)
        Player.Character.HumanoidRootPart.CFrame = targetCFrame
        EnsureTashiBlade()
        -- ìŠ¤í‚¬ ì‹¤í–‰
        SafeInvoke("SkillAction", {"SW_Tashi Blade_M1"})
        pcall(function()
            SafeInvoke("SkillAction", {"SW_Tashi Blade_X", {MouseHit = body.CFrame, Type = "Down"}})
            SafeInvoke("SkillAction", {"SW_Tashi Blade_Z", {MouseHit = body.CFrame, Type = "Up"}})
        end)
        return true
    end
    return false
end

local function TeleportToSeaKingWater()
    WaitForCharacter()
    local island = Workspace:FindFirstChild("Island")
    if island then
        local water = island:FindFirstChild("Sea King Water", true)
        if water and water:FindFirstChild("RootPart") then
            Player.Character.HumanoidRootPart.CFrame = water.RootPart.CFrame
            return true
        end
    end
    return false
end

-- ê²Œì„ ì…ì¥
SafeInvoke("EtcFunction", {"EnterTheGame", {}})

-- ì´ë™ ë£¨í”„
RunService.RenderStepped:Connect(function()
    TeleportToChest()
    TeleportToSeaKingBody()
    TeleportToSeaKingWater()
end)

-- ì„œë²„í™‰ íƒ€ì´ë¨¸
local lastChestTime, lastBodyTime, lastRootTime = 0,0,0
local serverHopPaused = false

local function ShouldHopServer()
    WaitForCharacter()
    
    -- SeaMonsterSpawnText ì²´í¬
    local remainingTime = ParseSeaMonsterTime()
    
    -- 59ì´ˆ ì´í•˜ë©´ ì„œë²„í™‰ ì¼ì‹œì •ì§€
    if remainingTime > 0 and remainingTime <= 59 then
        if not serverHopPaused then
            print("â³ SeaMonster ìŠ¤í°ê¹Œì§€ " .. remainingTime .. "ì´ˆ ë‚¨ìŒ. ì„œë²„í™‰ ì¼ì‹œì •ì§€.")
            serverHopPaused = true
        end
        return false
    end
    
    -- 0ì´ˆê°€ ë˜ë©´ ì„œë²„í™‰ ì¬ê°œ
    if remainingTime == 0 and serverHopPaused then
        print("âœ… SeaMonster ìŠ¤í° ì‹œê°„ ë„ë‹¬! ì„œë²„í™‰ ì¬ê°œ.")
        serverHopPaused = false
    end
    
    -- ì„œë²„í™‰ì´ ì¼ì‹œì •ì§€ëœ ìƒíƒœë¼ë©´ false ë°˜í™˜
    if serverHopPaused then
        return false
    end
    
    local island = Workspace:FindFirstChild("Island")
    local chestExists = island and island:FindFirstChild("ChestSpawner", true)
    local waterExists = island and island:FindFirstChild("Sea King Water", true) and island["Sea King Water"]:FindFirstChild("RootPart")
    local bodyExists = Workspace:FindFirstChild("SeaMonster")
        and Workspace.SeaMonster:FindFirstChild("SeaKing")
        and Workspace.SeaMonster.SeaKing:FindFirstChild("SeaKing")
        and Workspace.SeaMonster.SeaKing.SeaKing:FindFirstChild("Body")
    local now = tick()

    -- Body ì—†ê³  Chestë§Œ ìˆëŠ” ê²½ìš°
    if chestExists and not bodyExists then
        if lastChestTime == 0 then lastChestTime = now end
        if now - lastChestTime >= 10 then lastChestTime = 0 return true end
        return false
    else
        lastChestTime = 0
    end

    -- Body ìˆê³  Chest ìˆëŠ” ê²½ìš°
    if chestExists and bodyExists then
        lastBodyTime = now
        return false
    elseif not bodyExists and lastBodyTime > 0 then
        if now - lastBodyTime >= 10 then lastBodyTime = 0 return true end
        return false
    end

    -- RootPart ìˆëŠ” ê²½ìš°
    if waterExists then
        if lastRootTime == 0 then lastRootTime = now end
        if now - lastRootTime >= 10 then lastRootTime = 0 return true end
        return false
    else
        lastRootTime = 0
    end

    -- ëª¨ë“  ê²ƒì´ ì—†ìœ¼ë©´ ì¦‰ì‹œ ì„œë²„í™‰
    if not chestExists and not bodyExists and not waterExists then
        return true
    end

    return false
end

-- ì„œë²„ ëª©ë¡ ê¸°ë°˜ ë¬´í•œ ì„œë²„ í…”ë ˆí¬íŠ¸
local GetServersFunction = ReplicatedStorage:WaitForChild("Chest"):WaitForChild("Remotes")
    :WaitForChild("Functions"):WaitForChild("GetServers")
local currentJobId = game.JobId

print("ğŸ” ì„œë²„ ì¡°ê±´ ê¸°ë°˜ ë¬´í•œ ì„œë²„í™‰ ì‹œì‘")

while true do
    if ShouldHopServer() then
        local attemptedJobIds = {} -- ì´ë¯¸ ì‹œë„í•œ ì„œë²„ë“¤ ê¸°ë¡
        local foundValidServer = false
        
        while not foundValidServer do
            local serversToHopTo = {}
            local foundJobIds = {}
            local success, serversTable = pcall(function()
                return GetServersFunction:InvokeServer()
            end)

            if success and serversTable then
                for _, serverInfo in pairs(serversTable) do
                    local osTime = serverInfo.ServerOsTime
                    local serverJobId = serverInfo.JobId
                    if not osTime or serverJobId == currentJobId or foundJobIds[serverJobId] or attemptedJobIds[serverJobId] then 
                        continue 
                    end

                    local uptimeSeconds = os.time() - osTime

                    -- 3780ì´ˆì˜ ë°°ìˆ˜ì—ì„œ -60ì´ˆ ~ +300ì´ˆ ì—¬ìœ ë¥¼ ë‘” ì„œë²„ ì°¾ê¸° (1ì‹œê°„ ì´ìƒë§Œ)
                    if uptimeSeconds >= 3600 then -- 1ì‹œê°„ ì´ìƒë§Œ
                        local baseTime = math.floor(uptimeSeconds / 3780) * 3780
                        if baseTime > 0 then -- 3780ì´ˆ ë°°ìˆ˜ê°€ ìˆëŠ” ê²½ìš°
                            local minRange = baseTime - 60 -- -1ë¶„
                            local maxRange = baseTime + 300 -- +5ë¶„
                            
                            -- ë²”ìœ„ ë‚´ì— ìˆëŠ” ì„œë²„ ì„ íƒ
                            if uptimeSeconds >= minRange and uptimeSeconds <= maxRange then
                                table.insert(serversToHopTo, serverInfo)
                                foundJobIds[serverJobId] = true
                            end
                        end
                    end
                end
            end

            if #serversToHopTo > 0 then
                print("ğŸ¯ ì¡°ê±´ ë§ëŠ” ì„œë²„", #serversToHopTo, "ê°œ ë°œê²¬")
                
                local allAttempted = true
                for _, server in ipairs(serversToHopTo) do
                    print("â¡ï¸ ì„œë²„ í…”ë ˆí¬íŠ¸ ì‹œë„ JobId:", server.JobId)
                    attemptedJobIds[server.JobId] = true -- ì‹œë„í•œ ì„œë²„ ê¸°ë¡
                    
                    local tpSuccess, tpErr = pcall(function()
                        TeleportService:TeleportToPlaceInstance(place, server.JobId)
                    end)
                    
                    if tpSuccess then
                        print("âœ… í…”ë ˆí¬íŠ¸ ìš”ì²­ ì„±ê³µ JobId:", server.JobId)
                        foundValidServer = true
                        -- break ì œê±° - ì„±ê³µí•´ë„ ê³„ì† ë‹¤ë¥¸ ì„œë²„ë“¤ë„ ì‹œë„
                    else
                        warn("âŒ í…”ë ˆí¬íŠ¸ ì‹¤íŒ¨ JobId:", server.JobId, tpErr)
                    end
                    
                    task.wait(0.7) -- ê° í…”ë ˆí¬íŠ¸ ì‹œë„ ì‚¬ì´ 0.17ì´ˆ ëŒ€ê¸°
                end
                
                if foundValidServer then
                    print("ğŸ‰ í˜„ì¬ ë°°ì¹˜ì—ì„œ", #serversToHopTo, "ê°œ ì„œë²„ ëª¨ë‘ ì‹œë„ ì™„ë£Œ!")
                else
                    print("ğŸ”„ í˜„ì¬ ë°°ì¹˜ ì„œë²„ë“¤ ëª¨ë‘ ì‹¤íŒ¨, ìƒˆë¡œìš´ ì„œë²„ ëª©ë¡ ìš”ì²­ì¤‘...")
                    task.wait(1.7) --ervers í˜¸ì¶œ
                end
            else
                print("ğŸ˜¢ ì¡°ê±´ ë§ëŠ” ì„œë²„ ì—†ìŒ, ìƒˆë¡œìš´ ì„œë²„ ëª©ë¡ ìš”ì²­ì¤‘...")
                task.wait(0.17) -- 0.17ì´ˆ ëŒ€ê¸° í›„ ë‹¤ì‹œ GetServers í˜¸ì¶œ
            end
        end
    end
    task.wait(0.17)
end
